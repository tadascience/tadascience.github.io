{
  "hash": "fd7890d882f54578474e20431c93d44a",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"🧢 httr2::req_perform_stream(round = ) ⚾️\"\nauthor:\n  - name: Romain François\n    affiliation: tada⬢science\n    affiliation-url: https://tada.science\ndate: 2024-02-15\ncategories: [package, httr2, R, emoji]\nimage: https://httr2.r-lib.org/logo.png\ncitation: \n  url: https://tada.science/posts/2024-02-14-roses-are-red\ndraft: false\n---\n\n\n<a href=\"https://httr2.r-lib.org\"><img src=\"https://httr2.r-lib.org/logo.png\" align=\"left\" height=\"138\" style=\"margin: 10px\"/></a> httr2 is an amazing 📦 from the `r-lib` team. Built on top of the strong foundations of `curl`, experience from the previous incarnation with `httr` and tidy principles and design, `httr2` is an easy goto for anything api related.\n\nBut ... I found a bug 🪲, or let's call it a missed opportunity 🤓. TL;DR [it was fixed](https://github.com/r-lib/httr2/pull/437). Let's rewind.\n\n## In da beginning, there was emoji\n\n🎉 aka `:tada:` is the best emoji, this is not open for debate 😂.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(tada <- emo::ji(\"tada\"))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n🎉 \n```\n\n\n:::\n:::\n\n\nLet's dissect it with the help of 📦 [`utf8splain`](https://github.com/ThinkR-open/utf8splain) and [`uni`](https://github.com/ThinkR-open/uni) I totally forgot about. `tada` is a single code point emoji `U+1F389` aka `\"\\U1F389\"` in R:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncat(\"\\U1F389\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n🎉\n```\n\n\n:::\n\n```{.r .cell-code}\ndplyr::filter(uni::code, rune == \"U+1F389\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 7\n      id rune    description     block                 countries languages type \n   <int> <chr>   <chr>           <chr>                 <chr>     <chr>     <chr>\n1 127881 U+1F389 \" Party Popper\" miscellaneous-symbol… <NA>      <NA>      <NA> \n```\n\n\n:::\n:::\n\n\nIn utf-8, i.e. the encoding to rule them all, 🎉 is encoded with 4 bytes that follow the convention explained in [the UTF-8 wikipedia page](https://en.wikipedia.org/wiki/UTF-8#Encoding). `11110000` : starts with `11110` to indicate it is a 4 bytes encoded code point (or rune 🀄️), followed by 3 continuation bytes that start with `10` : `10011111, 10001110, 10001001`.\n\n(*I still don't know how to reveal the ansi escape codes in quarto, so using a screenshot instead so that you have colors 🌈).*\n\n![](tada.png){fig-align=\"left\"}\n\nJust like 🎉, many characters are encoded using more than on byte in utf-8 and other encodings.\n\n## golem poem\n\nWhile we're in [ThinkR](https://thinkr.fr) realm (`uni` and `utf8splain`) are weekend 📦 we developed when I was working with them 💜, let's look at what started this side quest of fixing a 🐞 in `httr2`. In the [tada::verse()](https://tada.science/posts/2024-02-02-tada-verse-poems/) post I introduced a function to compose 📦 poems with ChatGPT via the [mlverse/chattr](https://github.com/mlverse/chattr) package, and was annoyed that the function would not work to write a [`golem`](https://thinkr-open.github.io/golem/) poem.\n\n```         \n> chattr::chattr(\"Can you write a poem about the R package called 'golem'. Please add a bunch of emojis.\")\nSure! Here's a poem about the R package 'golem' with a bunch of emojis:\n\nError in `discard()`:\nℹ In index: 1.\nCaused by error:\n! `.p()` must return a single `TRUE` or `FALSE`, not `NA`.\nRun `rlang::last_trace()` to see where the error occurred.\nWarning messages:\n1: In strsplit(., \"data: \") :\n  unable to translate 'data: {\"id\":\"chatcmpl-8nsIIxlfPHfY8BhhuUu7NFsIO57AC\",\"object\":\"chat.completion.chunk\",\"created\":1706897470,\"model\":\"gpt-3.5-turbo-0613\",\"system_fingerprint\":null,\"choices\":[{\"index\":0,\"delta\":{\"role\":\"assistant\",\"content\":\"\"},\"logprobs\":null,\"finish_re...' to a wide string\n2: In strsplit(., \"data: \") : input string 1 is invalid\n```\n\nThat was embarrassing and curbed my enthusiasm about sharing the poem with the team. I still did, but I had to use the normal ChatGPT app like a human instead of the api 😥.\n\n## Fixing mlverse/chattr\n\n[mlerse/chattr](https://github.com/mlverse/chattr) is not the only R 📦 that can speak to `ChatGPT` and I successfully used [irudnyts/openai](https://irudnyts.github.io/openai/) for another similar quest with the `valentine` package that writes [roses are red ...](https://tada.science/posts/2024-02-14-roses-are-red/) poems about packages. This does work, e.g.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalentine::roses(\"golem\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nRoses are red 🌹\nGolem's my friend till the end 😊\nWith its powers and might ✨\nBuilding apps becomes a delight! 🚀\n```\n\n\n:::\n:::\n\n\nThe advantage of `mlverse/chattr` though is that is uses streaming to get tokens faster rather than wait for the whole poem to be composed.\n\nSo naturally, I went for a dive on how `mlverse/chattr` works, using [snitch](https://tada.science/posts/2024-02-04-snitch/) to get some understanding of its implementation, and sending [a bottle in the issues](https://github.com/mlverse/chattr/issues/63) in case the `chattr` team wanted to spare my quest.\n\nI sent a first clunky [pull request](https://github.com/mlverse/chattr/pull/64) that did the job, while looking kind of ugly and hacky. When that happens, that's usually a good sign that this is a solution to the wrong problem, so I abandonned that PR and decided to go earlier in the 📦 chain and look at [r-lib/httr2](https://httr2.r-lib.org) because `chattr` uses `httr2::req_perform_stream()` to ... process the stream.\n\nThe stream from ChatGPT is processed by fixed-size chunks of bytes, and so the problem was that on occasions, these chunks cut an emoji in the middle, which causes issues down the line:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntad <- charToRaw(tada)[1:3]\ntad\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] f0 9f 8e\n```\n\n\n:::\n\n```{.r .cell-code}\nrawToChar(tad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"\\xf0\\x9f\\x8e\"\n```\n\n\n:::\n\n```{.r .cell-code}\nnchar(tad)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 2 2 2\n```\n\n\n:::\n:::\n\n\nThis confused other parts of the `mlverse/chattr` codebase.\n\n## Fixing r-lib/httr2\n\nNow that this was reframed as a missed `r-lib/httr2` opportunity, and I had been looking for an excuse to peep on how `httr2` works, I deep dived and opened a [pull request](https://github.com/r-lib/httr2/pull/437) last week. Hadley started to review it the next day and we 🏓 on it and iterated a few times until we were happy about it.\n\n![](pr.png){fig-align=\"center\"}\n\nIt is now merged, and so will be released as part of the next `httr2` release, but you can take it for a spin with `pak::pak(\"r-lib/httr2\")`.\n\nMy initial proposal was to add a `req_perform_stream_lines()`, based on the idea that if we know the stream is text encoded in utf-8, instead of streaming all the bytes, and taking the risk that chunks might cut emojis or other character mid rune, we can buffer the bytes and process line by line.\n\nThis kind of worked, but we ended up having the two sister functions `req_perform_stream()` and `req_perform_stream_lines()` that shared a lot of logic but were different. Something was off.\n\nWe continued to iterate, and Hadley has been as usual generous with reviewing and improving the pull request. Hadley even contributed the tests that allowed us to 🏃‍♂️ the last kilometer 💚.\n\nWe settled on adding the extra argument `round=` to the `req_perform_stream()` function, so that instead of processing fixed-size chunks of bytes, the callback function could receive a truncated sequence of bytes.\n\nHere is the updated documentation for `req_perform_stream()` :\n\n![](round.png)\n\nThe default behavior remains `round = \"byte\"` so that the risk of the pull request being dispruptive is minimal, so by default the full chunk of `buffer_kb` kilobytes is sent to the `callback`.\n\nThe added value of the pull request though is that you can now `round = \"line\"` so that the stream is buffered and cut at the last newline character, a new line is a character that is encoded in a single byte, i.e. its utf-8 representation is the same as its ascii `00001010` .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutf8splain::runes(\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nutf-8 encoded string with 1 runes\n\nU+000A   0A   00001010    New Line (Nl) : line feed (lf) : end of line (eol) : LF\n```\n\n\n:::\n\n```{.r .cell-code}\nutf8splain::bytes(\"\\n\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 4\n     id byte  decimal binary  \n  <int> <raw>   <int> <chr>   \n1     1 0a         10 00001010\n```\n\n\n:::\n:::\n\n\nWe also contemplated on implementing `round = \"utf8\"` to round at the last valid utf-8 sequence, but we eventually arbitrated that it's probably not worth it at this stage.\n\nBut `round =` is flexible enough to accomodate for other ways of rounding, and is passed through the internal `httr2::as_round_function()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nas_round_function <- function(round = c(\"byte\", \"line\"),\n                              error_call = caller_env()) {\n  if (is.function(round)) {\n    check_function2(round, args = \"bytes\")\n    round\n  } else if (is.character(round)) {\n    round <- arg_match(round, error_call = error_call)\n    switch(round,\n      byte = function(bytes) length(bytes),\n      line = function(bytes) which(bytes == charToRaw(\"\\n\"))\n    )\n  } else {\n    cli::cli_abort(\n      '{.arg round} must be \"byte\", \"line\" or a function.',\n      call = error_call\n    )\n  }\n}\n```\n:::\n\n\nI'll talk about `cli_abort()`, `arg_match()` and `error_call` some other day. Working on this pull request was great and I believe we end up with the right solution.\n\n## Fixing mlverse/chattr, take 2\n\nWith `req_perform_stream(round = \"line\")` it becomes much easier to fix the initial problem, so I could send a second [pull request](https://github.com/mlverse/chattr/pull/65) there, and now with the dev version of `httr2` and the pull request of `chattr` we can finally enjoy the `golem` poem:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# pak::pak(\"mlverse/chattr#65\")\nchattr::chattr_use(\"gpt35\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n── chattr \n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Provider: Open AI - Chat Completions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Path/URL: https://api.openai.com/v1/chat/completions\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n• Model: gpt-3.5-turbo\n```\n\n\n:::\n\n```{.r .cell-code}\ntada::verse(\"golem\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSure! Here's a poem about the R package 'golem' with a bunch of emojis:\n\n🌟 In the land of R, a package was born,\n🔧 Its name was 'golem', a tool to adorn.\n🏗️ With 🧱 and 🏗️, it built apps with ease,\n🌈 Adding colors and interactivity, oh please!\n\n📦 'Golem' wrapped up shiny, like a gift,\n🎁 Making web apps with a magical lift.\n🌐 It brought the power of the web to R,\n🖥️ Creating interfaces that would take you far.\n\n🔮 With 'golem', you could create something new,\n🎨 Designing apps with a beautiful view.\n📊 Visualize data with 📈 and 📉,\n🔍 Explore insights with a few clicks and scrolls.\n\n🔒 'Golem' protected your code like a shield,\n🛡️ Keeping it safe, never to yield.\n🔐 With authentication and authorization,\n🔒 Your app's security was never a question.\n\n🚀 So, let's embark on a 'golem' adventure,\n🌠 Building apps with joy and rapture.\n💻 Code, create, and let your imagination soar,\n🌟 With 'golem', the possibilities are forevermore!\n```\n\n\n:::\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}