{
  "hash": "2331c128bbfb1b4186c484e19f1b4e40",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"snitch\"\ndescription: \"The experimental snitch 📦 spies on functions and packages\"\nauthor:\n  - name: Romain François\n    affiliation: tada⬢science\n    affiliation-url: https://tada.science\ndate: 2024-02-02\ncategories: [R, snitch]\nimage: logo.png\ncitation: \n  url: https://tada.science/posts/2024-02-04-snitch\ndraft: false\n---\n\n\n<a href=\"https://snitch.tada.science\"><img src=\"logo.png\" align=\"left\" height=\"138\"/></a>\n\nThe snitch 📦 is one of those weekend experiments. In this particular case, it comes from *I don't know how to use base::trace() and I want a thing that tells me how a particular function is called,* so I want to spy on a function.\n\nThe name and logo of the package might be because I've started to read the first Harry Potter book to my 6 years old daughter 🧙.\n\nDALL-E gave a decent logo once I removed explicit HP references 🤷‍♂️, i.e. *\"a small gold colored spherical object with wings\"* instead of *\"the golden snitch\":*\n\n> Can you make an hexagon logo for an R package called snitch, inspired by a small gold colored spherical object with wings. The package goal is to spy on function calls.\n\nAnyway 🤖, let's dive in, you can install it with `pak::pak(\"tadascience/snitch\")` I'm not sure at this point this will make its way to CRAN.\n\nThe package has `snitch::fun()` to spy on a function ... *(I don't know how to get the colors in quarto so let's go with a screenshot)*. You first get a [rule](https://cli.r-lib.org/reference/cli_rule.html) with breadcrumbs of functions that are spyed on, and then their arguments, courtesy of `ls.str()` :\n\n![](fun.png){fig-align=\"center\"}\n\n... and `snitch::pkg()` to spy on functions from a package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsuppressPackageStartupMessages(library(dplyr))\nsnitch::pkg(\"dplyr\", pattern = \"^summarise_\")\n\nmtcars %>%\n  summarise(mean = mean(disp), n = n())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n── summarise_cols ──────────────────────────────────────────────────────────────\n   by : List of 3\n    $ type : chr \"ungrouped\"\n    $ names: chr(0) \n    $ data : tibble [1 × 1] (S3: tbl_df/tbl/data.frame)\n   data : 'data.frame':\t32 obs. of  11 variables:\n    $ mpg : num  21 21 22.8 21.4 18.7 18.1 14.3 24.4 22.8 19.2 ...\n    $ cyl : num  6 6 4 6 8 6 8 4 4 6 ...\n    $ disp: num  160 160 108 258 360 ...\n    $ hp  : num  110 110 93 110 175 105 245 62 95 123 ...\n    $ drat: num  3.9 3.9 3.85 3.08 3.15 2.76 3.21 3.69 3.92 3.92 ...\n    $ wt  : num  2.62 2.88 2.32 3.21 3.44 ...\n    $ qsec: num  16.5 17 18.6 19.4 17 ...\n    $ vs  : num  0 0 1 1 0 1 0 1 1 1 ...\n    $ am  : num  1 1 1 0 0 0 0 0 0 0 ...\n    $ gear: num  4 4 4 3 3 3 3 4 4 4 ...\n    $ carb: num  4 4 1 1 2 1 4 2 2 4 ...\n   dots : List of 2\n    $ mean: language ~mean(disp)\n    $ n   : language ~n()\n   error_call : <environment: 0x107b31a98> \n   verb :  chr \"summarise\"\n── summarise_cols ⬢ FUN ────────────────────────────────────────────────────────\n   mask : Classes 'DataMask', 'R6' <DataMask>\n     Public:\n       add_one: function (name, chunks, result) \n       clone: function (deep = FALSE) \n       current_cols: function (vars) \n       current_key: function () \n       current_non_group_vars: function () \n       current_rows: function () \n       current_vars: function () \n       eval_all: function (quo) \n       eval_all_filter: function (quos, env_filter) \n       eval_all_mutate: function (quo) \n       eval_all_summarise: function (quo) \n       forget: function () \n       get_current_data: function (groups = TRUE) \n       get_current_group_id: function () \n       get_current_group_id_mutable: function () \n       get_current_group_size: function () \n       get_current_group_size_mutable: function () \n       get_keys: function () \n       get_rlang_mask: function () \n       get_rows: function () \n       get_size: function () \n       get_used: function () \n       initialize: function (data, by, verb, error_call) \n       is_grouped: function () \n       is_rowwise: function () \n       pick_current: function (vars) \n       remove: function (name) \n       resolve: function (name) \n       set_current_group: function (group) \n       unused_vars: function () \n     Private:\n       by_names: \n       chops: environment\n       current_data: list\n       env_current_group_info: environment\n       env_mask_bindings: environment\n       grouped: FALSE\n       keys: tbl_df, tbl, data.frame\n       rows: vctrs_list_of, vctrs_vctr, list\n       rowwise: FALSE\n       size: 32\n       verb: summarise \n   quo :  language ~mean(disp)\n── summarise_cols ⬢ FUN ────────────────────────────────────────────────────────\n   mask : Classes 'DataMask', 'R6' <DataMask>\n     Public:\n       add_one: function (name, chunks, result) \n       clone: function (deep = FALSE) \n       current_cols: function (vars) \n       current_key: function () \n       current_non_group_vars: function () \n       current_rows: function () \n       current_vars: function () \n       eval_all: function (quo) \n       eval_all_filter: function (quos, env_filter) \n       eval_all_mutate: function (quo) \n       eval_all_summarise: function (quo) \n       forget: function () \n       get_current_data: function (groups = TRUE) \n       get_current_group_id: function () \n       get_current_group_id_mutable: function () \n       get_current_group_size: function () \n       get_current_group_size_mutable: function () \n       get_keys: function () \n       get_rlang_mask: function () \n       get_rows: function () \n       get_size: function () \n       get_used: function () \n       initialize: function (data, by, verb, error_call) \n       is_grouped: function () \n       is_rowwise: function () \n       pick_current: function (vars) \n       remove: function (name) \n       resolve: function (name) \n       set_current_group: function (group) \n       unused_vars: function () \n     Private:\n       by_names: \n       chops: environment\n       current_data: list\n       env_current_group_info: environment\n       env_mask_bindings: environment\n       grouped: FALSE\n       keys: tbl_df, tbl, data.frame\n       rows: vctrs_list_of, vctrs_vctr, list\n       rowwise: FALSE\n       size: 32\n       verb: summarise \n   quo :  language ~n()\n── summarise_build ─────────────────────────────────────────────────────────────\n   by : List of 3\n    $ type : chr \"ungrouped\"\n    $ names: chr(0) \n    $ data : tibble [1 × 1] (S3: tbl_df/tbl/data.frame)\n   cols : List of 3\n    $ new    :List of 2\n    $ sizes  : int 1\n    $ all_one: logi TRUE\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n      mean  n\n1 230.7219 32\n```\n\n\n:::\n:::\n\n\nIs it useful, I don't know, but I like it, and I prefer typing `snitch::fun()` than remembering how to use `trace()`.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}